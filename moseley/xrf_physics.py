"""Predicting elemental XRF (X-Ray Fluorescence) spectra"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/01_all-you-need-to-know-about-x-ray-fluorescence.ipynb.

# %% auto 0
__all__ = ['ElementXRF', 'get_element_spectra', 'gaussian_convolve', 'find_peaks', 'plot_spectrum']

# %% ../notebooks/01_all-you-need-to-know-about-x-ray-fluorescence.ipynb 7
import numpy as np 
import xraydb 
import pandas as pd 
import scipy.signal as ssg 
import scipy.interpolate as sip
import matplotlib.pyplot as plt

# %% ../notebooks/01_all-you-need-to-know-about-x-ray-fluorescence.ipynb 8
class ElementXRF(): 
    '''Computes fluorescence emission line energies and intensities for `element`. 
    
    '''
    
    def __init__(self, element, excitation_energy_keV=None, tube_anode='Rh', x_keVs=None, std=0.01, min_prom=0.001): 

        ### LINES ### 

        if (excitation_energy_keV is None) and (tube_anode=='Rh'): 
            excitation_energy_keV = 23 

        excitation_energy = 1000 * excitation_energy_keV # keV -> eV 

        lines = xraydb.xray_lines(element, excitation_energy=excitation_energy) 

        line_names = [] # Siegbahn notation
        line_labels = [] # IUPAC notation 
        line_energies = [] 
        line_probabilities = [] 

        line_fluo_yields = []
        line_jump_coeffs = [] 
        line_intensities = []
        
        for name, line in lines.items(): 

            # xraydb 'intensities' (a.k.a. transition probablities) sum up to unity within each level 
            energy, probability, initial_level, final_level = line  
            label = f'{element}_{initial_level}{final_level}' #  construct IUPAC notation 
            
            # get corresponding edge properties 
            edge = initial_level # IUPAC notation!  e.g. 'L1', not 'La'
            edge_energy, fluo_yield, jump_ratio = xraydb.xray_edge(element, edge) 
            jump_coeff = (jump_ratio - 1) / jump_ratio # see Volker Thomsen 
            #print(f'{name}: {energy}; jump_coeff: {jump_coeff:.03f}; fluo_yield: {fluo_yield}')

            # multiplying edge jump coefficient, transition probability and fluorescence yield... 
            intensity = jump_coeff * probability * fluo_yield 

            line_names.append(name) 
            line_labels.append(label)
            line_energies.append(energy / 1000)
            line_probabilities.append(probability)  
            
            line_fluo_yields.append(fluo_yield)
            line_jump_coeffs.append(jump_coeff) 
            line_intensities.append(intensity) 

        self.lines_table = pd.DataFrame({'name': line_names, 
                                         'label': line_labels, 
                                         'energy': line_energies, 
                                         'trans_prob': line_probabilities, 
                                         'fluo_yield': line_fluo_yields, 
                                         'jump_coeff': line_jump_coeffs, 
                                         'intensity': line_intensities}) 

    
        ### CONTINUOUS ### 
        
        self.spectrum_xy = gaussian_convolve(line_energies, line_intensities, x_keVs=x_keVs, std=std) 
        self.peaks_xy = find_peaks(*self.spectrum_xy, min_prom=min_prom) 

    def plot_spectrum(self, ax=None, color=None, vlines_colors=None): 
        
        ax = plot_spectrum(self ,ax=ax, color=color, vlines_colors=vlines_colors)
        
        return ax 

            
    
def get_element_spectra(elements, x_keVs, excitation_energy_keV): 
    '''Compute theoretical emission spectrum for multiple elements. 
    
    Sorts elements according to largest (alpha) peak. Based on xraydb. 
    
    Returns: elements, element_spectra
    '''

    n_channels = len(x_keVs)
    n_elements = len(elements)

    element_spectra = np.zeros([n_elements, n_channels]) 

    for i, elem in enumerate(elements): 
        element_spectra[i] = get_element_spectrum(elem, excitation_energy_keV, x_keVs=x_keVs)

        # normalize
        element_spectra[i] = element_spectra[i] / element_spectra[i].max()


    # sort according to energy of largest (=alpha) peak
    alpha_idxs = np.argmax(element_spectra, axis=1)
    alpha_order = np.argsort(alpha_idxs) 

    elements = [elements[i] for i in alpha_order]
    element_spectra = element_spectra[alpha_order]
    
    return elements, element_spectra 


def gaussian_convolve(peak_energies, peak_intensities, x_keVs=None, std=0.01): 
    '''Convolves line spectrum defined by `peak_energies` and `peak_intensities` 
    
    with a Gaussian peak shape.'''
    
    if x_keVs is None: 
        x_keVs = np.linspace(0, 40, 10000)

    y_spectrum = np.zeros_like(x_keVs) 

    for peak_energy, peak_intensity in zip(peak_energies, peak_intensities): 

        y_spectrum += peak_intensity * np.exp(-(1 / std) * (x_keVs - peak_energy)**2)
        
    return x_keVs, y_spectrum  

def find_peaks(x, y, min_prom=0.001):  
    '''Find peaks in spectrum `x`, `y` with minimal prominence `min_prom=`
    
    Returns: peaks_xy''' 
    
    # find the peaks (channel indexes) 
    peaks, props = ssg.find_peaks(y, prominence=[min_prom, None])

    peaks_x = x[peaks]
    peaks_y = y[peaks] 
    
    # sort according to peak_height 
    sort_idxs = np.argsort(peaks_y)[::-1] 

    peaks_x = peaks_x[sort_idxs]
    peaks_y = peaks_y[sort_idxs]
    peaks_xy = [peaks_x, peaks_y]

    return peaks_xy 


def plot_spectrum(element_xrf, ax=None, color=None, vlines_colors=None): 

    if ax is None: 
        fig, ax = plt.subplots() 

    x, y = element_xrf.spectrum_xy 
    peaks_x, peaks_y = element_xrf.peaks_xy

    ax.plot(x, y, color=color)
    ax.scatter(peaks_x[0], peaks_y[0], marker='s', facecolor='w', edgecolor=color, zorder=10)  
    ax.scatter(peaks_x[1:], peaks_y[1:], marker='o', facecolor='w', edgecolor=color, zorder=10)

    # need to interpolate spectrum to add vlines 

    spectrum = sip.interp1d(x, y)
    line_keVs = element_xrf.lines_table['energy'] 

    line_heights = spectrum(line_keVs)

    ax.vlines(line_keVs, np.zeros_like(line_keVs), line_heights, colors=vlines_colors) 
    
    return ax 
        
    
