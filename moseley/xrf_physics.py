"""Predicting elemental XRF (X-Ray Fluorescence) spectra"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/01_theoretical-peak-patterns.ipynb.

# %% auto 0
__all__ = ['ElementXRF', 'get_element_spectra', 'gaussian_convolve', 'find_peaks', 'plot_pattern']

# %% ../notebooks/01_theoretical-peak-patterns.ipynb 9
import numpy as np 
import xraydb 
import pandas as pd 
import scipy.signal as ssg 
import scipy.interpolate as sip
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import mendeleev

# %% ../notebooks/01_theoretical-peak-patterns.ipynb 10
class ElementXRF(): 
    '''Computes fluorescence emission line energies and intensities for `element`. 
    
    '''
    
    def __init__(self, element, excitation_energy_keV=None, tube_anode='Rh', x_keVs=None, std=0.01, min_prom=0.001): 
        '''Create elemental xrf spectrum object. '''

        ### LINES ### 

        if (excitation_energy_keV is None) and (tube_anode=='Rh'): 
            excitation_energy_keV = 23 

        self.element = element 

        excitation_energy = 1000 * excitation_energy_keV # keV -> eV 

        lines = xraydb.xray_lines(element, excitation_energy=excitation_energy) 

        line_names = [] # Siegbahn notation
        line_labels = [] # IUPAC notation 
        line_energies = [] 
        line_probabilities = [] 

        line_fluo_yields = []
        line_jump_coeffs = [] 
        line_intensities = []
        
        for name, line in lines.items(): 

            # xraydb 'intensities' (a.k.a. transition probablities) sum up to unity within each level 
            energy, probability, initial_level, final_level = line  
            label = f'{element}_{initial_level}{final_level}' #  construct IUPAC notation 
            
            # get corresponding edge properties 
            edge = initial_level # IUPAC notation!  e.g. 'L1', not 'La'
            edge_energy, fluo_yield, jump_ratio = xraydb.xray_edge(element, edge) 
            jump_coeff = (jump_ratio - 1) / jump_ratio # see Volker Thomsen 
            #print(f'{name}: {energy}; jump_coeff: {jump_coeff:.03f}; fluo_yield: {fluo_yield}')

            # multiplying edge jump coefficient, transition probability and fluorescence yield... 
            intensity = jump_coeff * probability * fluo_yield 

            line_names.append(name) 
            line_labels.append(label)
            line_energies.append(energy / 1000)
            line_probabilities.append(probability)  
            
            line_fluo_yields.append(fluo_yield)
            line_jump_coeffs.append(jump_coeff) 
            line_intensities.append(intensity) 

        self.lines_table = pd.DataFrame({'name': line_names, 
                                         'label': line_labels, 
                                         'energy': line_energies, 
                                         'trans_prob': line_probabilities, 
                                         'fluo_yield': line_fluo_yields, 
                                         'jump_coeff': line_jump_coeffs, 
                                         'intensity': line_intensities}) 

    
        ### CONTINUOUS ### 
        
        self.spectrum_xy = gaussian_convolve(line_energies, line_intensities, x_keVs=x_keVs, std=std) 
        self.peaks_xy = find_peaks(*self.spectrum_xy, min_prom=min_prom) 

    def plot_spectrum(self, ax=None, edgecolor=None, facecolor=None, vlines_colors=None, xlim=[0, 25]): 
        
        if edgecolor is None: 
            edgecolor = cm.tab20(0)
        if facecolor is None: 
            facecolor = 'w' 
    
        if ax is None: 
            fig, ax = plt.subplots() 
    
        x, y = self.spectrum_xy 
        peaks_x, peaks_y = self.peaks_xy.T
    
        ax.plot(x, y, color=edgecolor, zorder=9)
        ax.scatter(peaks_x[0], peaks_y[0], marker='s', facecolor=facecolor, edgecolor=edgecolor, zorder=10)  
        ax.scatter(peaks_x[1:], peaks_y[1:], marker='o', facecolor=facecolor, edgecolor=edgecolor, zorder=10)
    
        # need to interpolate spectrum to add vlines 
    
        spectrum = sip.interp1d(x, y)
        line_keVs = self.lines_table['energy'] 
    
        line_heights = spectrum(line_keVs)
    
        ax.vlines(line_keVs, np.zeros_like(line_keVs), line_heights, colors=vlines_colors, alpha=0.5, zorder=8) 

        ax.set_title(f'Theoretical X-Ray Fluorescence for {self.element}') 
        ax.set_xlabel('Energy (keV)')
        ax.set_xlim(xlim)
        
        return ax 

    def get_pattern_dict(self): 
    
        alpha_keV = float(self.peaks_xy[0][0])
        alpha_escape_keV = alpha_keV - 1.74  # Silicon detector escape energy shift 
        
        # element   
        elem = self.element
        name = mendeleev.element(elem).name
        atomic_number = mendeleev.element(elem).atomic_number
        
        ptrn_dict = {'elem': elem,  
                     'atomic_number': atomic_number, 
                     'alpha_keV': alpha_keV, 
                     'name': name, 
                     'peaks_xy': self.peaks_xy, 
                     'alpha_escape_keV': alpha_escape_keV} 
        
        return ptrn_dict
    
def get_element_spectra(elements, x_keVs, excitation_energy_keV): 
    '''Compute theoretical emission spectrum for multiple elements. 
    
    Sorts elements according to largest (alpha) peak. Based on xraydb. 
    
    Returns: elements, element_spectra
    '''

    n_channels = len(x_keVs)
    n_elements = len(elements)

    element_spectra = np.zeros([n_elements, n_channels]) 

    for i, elem in enumerate(elements): 
        element_spectra[i] = get_element_spectrum(elem, excitation_energy_keV, x_keVs=x_keVs)

        # normalize
        element_spectra[i] = element_spectra[i] / element_spectra[i].max()


    # sort according to energy of largest (=alpha) peak
    alpha_idxs = np.argmax(element_spectra, axis=1)
    alpha_order = np.argsort(alpha_idxs) 

    elements = [elements[i] for i in alpha_order]
    element_spectra = element_spectra[alpha_order]
    
    return elements, element_spectra 


def gaussian_convolve(peak_energies, peak_intensities, x_keVs=None, std=0.01): 
    '''Convolves line spectrum defined by `peak_energies` and `peak_intensities` 
    
    with a Gaussian peak shape.'''
    
    if x_keVs is None: 
        x_keVs = np.linspace(0, 40, 10000)

    y_spectrum = np.zeros_like(x_keVs) 

    for peak_energy, peak_intensity in zip(peak_energies, peak_intensities): 

        y_spectrum += peak_intensity * np.exp(-(1 / std) * (x_keVs - peak_energy)**2)
        
    return x_keVs, y_spectrum  

def find_peaks(x, y, min_prom=0.001):  
    '''Find peaks in spectrum `x`, `y` with minimal prominence `min_prom=`
    
    Returns: peaks_xy''' 
    
    # find the peaks (channel indexes) 
    peaks, props = ssg.find_peaks(y, prominence=[min_prom, None])

    peaks_x = x[peaks]
    peaks_y = y[peaks] 
    
    # sort according to peak_height 
    sort_idxs = np.argsort(peaks_y)[::-1] 

    peaks_x = peaks_x[sort_idxs]
    peaks_y = peaks_y[sort_idxs]
    
    peaks_xy = np.c_[peaks_x, peaks_y]

    return peaks_xy 

def plot_pattern(ptrn_dict, ax=None, offset=0, color=None): 
    '''Plot a single element peak pattern. 
    ''' 
        
    element = ptrn_dict['elem']
    
    x, _ = ptrn_dict['peaks_xy'].T
    y = np.zeros_like(x) + offset 
    alpha_escape_keV = ptrn_dict['alpha_escape_keV']
         
    left_x = min(x)
    right_x = max(x) 

    if color is None: 
        facecolor = 'w'
        edgecolor = 'grey'
        linecolor = 'grey'
        linestyle = ':'

    else: 
        facecolor = color 
        edgecolor = 'k'
        linecolor = color
        linestyle = '-'

    if ax is None: 
        fig, ax = plt.subplots() 

    ax.scatter(x, y, s=15, facecolor=facecolor, edgecolor=edgecolor)
    ax.scatter(x[0], y[0], marker='s', facecolor=facecolor, edgecolor=edgecolor)
    ax.plot([left_x, right_x], [y[0], y[0]], color=edgecolor, linestyle=linestyle, zorder=-10)
    ax.scatter(alpha_escape_keV, y[0], marker='|', color=edgecolor) 
    ax.annotate(element, [right_x, y[0]], xytext=[5, -1], fontsize=8, color='k', 
                textcoords='offset points', ha='left', va='center') 
   
    return ax 
